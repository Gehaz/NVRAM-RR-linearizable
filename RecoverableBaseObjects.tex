
\section{Recoverable Base Objects}
\label{section: Recoverable Base Objects}

We consider a model in which the program counter (PC) is stored in the non-volatile memory. This can be done either explicitly in the program, or implicitly by the operating system. In this model, upon recovery the last PC is available, and the system knows during what operation the process crash, and thus the proper \texttt{Recover} function is invoked. As a result, there is uncertainty regarding whether the last instruction was performed or not. We also assume the \texttt{Recover} function has an access to the last PC before the crash, or in other words, it is aware of at what line the crash took place.

The following example clarify why do we need the definition of recoverable object to holds even for the case of primitives.
Consider an object supporting a compare-and-swap (CAS) atomic operation. Assume a process $p$ is executing an operation $res \leftarrow C.CAS(old,new)$ followed by a crash. There are several options for at what exact time the crash took place, and each case raises a different problem.

In the standard crash model, a primitive operation is atomic and takes effect instantly in the history, that is, the response follows the invocation in the history, where no other step by any other process is allowed in between. Under the same definition, and assuming the process crash just after completing the CAS operation and before advancing the PC, there was a response step in the history, and thus the RR-linearizability does not require the process to recover the operation. However, the operation is still pending in some sense, as upon recovery the process does not know whether it took affect or not, since the PC still points the same line and $res$ content was erased.

Considering the response of the CAS operation to be at the time where the PC is being advanced solves the former problem. Nevertheless, what if the process crash just after the PC was changed? Again, the operation is not pending, so there is no need to recover it. In this case, upon recovery the process knows the operation was completed, since the PC no longer points to it. However, the process have no access to the response value that was stored in $res$, residing in the cache, and hence it may not be able to proceed its execution.

A recoverable version of CAS avoids the above problems. The operation considered to be complete only after both the CAS was linearized, and the response value is persistent in $Res_p$. Therefore, a crash after this point can cause no problem, as the process knows the operation was completed as well as have an access to the response value.

In the following section we present algorithms for implementing recoverable versions for well known primitives. A system equipped with such primitives can be used to implement any object in a recoverable way in the following manner: in case of a crash, the process will simply recover the last primitive operation along which the process crashed. Once the operation completes, the process can continue and execute the remaining code safely. Due to this observation we focus our attention to implementation of recoverable primitives.

The progress property considered is bounded wait-free, that is, the number of steps a process takes when executing the recovery code in the absence of a failure is finite and bounded by a known constant (may be a function of n, the number of processes in the system), regardless of the other processes steps and the failures the process experienced so far. In addition, we would like the recovery code to use a finite number of variables.
The fact that RR-linearizability allows us to swift the linearization point of an operation to after the crash is used to recover after a primitive failure.

The recoverable object definition requires the response value to be persistent for any operation. However, this requirement is inefficient in case of a trivial response as $ack$. In this case there is no point to save the response value in the non-volatile memory, as the only information relevant for the process is whether the operation was complete or not. For such an operation we define the response step to be at the point where to PC no longer points the code implementing the operation, and we do not persist the response value. This observation can be used for any operation with a trivial response, even though the recoverable object definition is general and does not handle these cases separately.

In addition, the question of having a crash along a \texttt{Recover} function needs to be address. One option is to assume a crash can not occur along executing a \texttt{Recover} function. In practice this might be reasonable to assume a short time of stability in the system following a crash. However, we wold like to have a stronger model, capable dealing with crash even along a \texttt{Recover} function. Notice also that a \texttt{Recover} function which uses only such recoverable primitives is itself recoverable.

In the following, we use the convention of capital letters names for shred variables and small letters for local variables. Also, an abort response of the \texttt{Recover} function implies the operation is not linearized and the process can safely restart it. During the analysis we ignore the ABA problem, as this can be solved easily by augmenting any value with the writing process's id, and a sequential number (each process will have its own sequential number). This way we can guarantee no two identical values are used along any execution.

\paragraph*{Read}

Following the formal definition of RR-linearizability, a process will need to write the value it reads to $Res_p$ in order to implement a recoverable read. However, such an implementation is redundant and not efficient. In case the process crash before completing its read operation it can simply reissue it upon recovery.

In general, operations that only reads the status of an object and does not change it (more formally, operation that can be commute with any other operation by a different process), usually uses only read primitive (e.g., snapshot), or at least implemented in a way such that if a process crash in the middle of an operation then reissue it does not affect the rest of the processes. In such cases, one can implement a recoverable version of the operation by having the \texttt{Recover} function reissuing the operation.

\paragraph*{Write}
For write, we "wrap" the atomic write with a mechanism which allows the process to conclude whether its write or a different write took place since the invocation. For that, process $p$ have a designated variable $R_p$ in the non-volatile memory. The same variable can be used for all write operations of process $p$.

\begin{algorithm}
	\caption{Write}\label{recoverable write}
	\begin{algorithmic}[1]	
		\Procedure{write}{}
		\State $temp \gets R$
		\State $R_p \gets temp$
		\State $R \gets val$
		\EndProcedure
		
		\Procedure{Recover}{}
		\If {$pc < 4$} \Return abort
		\EndIf
		\If {$R_p == R$} \Return abort
		\EndIf
		\EndProcedure
	\end{algorithmic}
	\caption{R.write(val) by process $p$}
\end{algorithm}

For simplicity, we write the recovery code as a single instruction, although it needs to be written as several instructions, as it accesses two different locations in the shared memory. Since $R_p$ is designated to $p$ only, the point where $p$ reads $R$ determines the \texttt{Recover} function outcome.

The intuition for correctness is the following. If there was a write to $R$ between the two reads of $p$ (at line 2, and at the \texttt{Recover} function), then either this write is by $p$, and we can linearize it at the point where it took affect, or that there was a write by some other process, and we can linearize the write of $p$ just before it. Hence, the real write "overwrite" $p$'s write, and the rest of the processes can not distinguish between the two scenarios. Thus, in case of a failure before line 4 the operation will be aborted.


\paragraph*{Compare-and-Swap}

A Compare-and-Swap (CAS) object supports the $cas(old,new)$ operation, which atomically compares the value stored in the object to old, and if they are equal, sets the value to be new. The operation returns the compression's result, that is, if the operation succeeded or failed. CAS object also support a read operation which returns the value stored in the object.

The main idea is to have the CAS stored also the if of a process who last committed a successful CAS. Thus, a process can inform a different process if its CAS operation was successful.
A process $p$ first reads the CAS object. If it observes a value different then $old$ it returns false. In such case, the operation is linearized at the linearization point of the read. Otherwise, $p$ informs the last process who committed a successful CAS that his operation was completed by writing to a designated location in the non-volatile memory. This way, if $p$ crash after a successful CAS operation, the next process which change the value of the CAS, first needs to inform $p$ his CAS was successful. Therefore, upon recovery $p$ can identify if its CAS took affect by seeing his value in $C$, or that some other process informed him about a success.

\begin{algorithm}
	\caption{Compare-and-Swap}\label{recoverable CAS}
	
	\hspace*{\algorithmicindent} \textbf{Shared variables:}
	\begin{itemize}
		\item C: compare-and-swap object, init $<null,null>$
		\item R[N][N]: two dimensions array, init $null$
	\end{itemize}
 
	\begin{algorithmic}[1]
		\Procedure{CAS}{}
		\State $<id,val> \gets C.read()$
		\If {$val \neq null$ and $val \neq old$}
		\State \Return false
		\EndIf
		\If {$id \neq null$}
  		\State $R[id][p] \gets val$
		\EndIf
		\State $ret \gets C.cas(<id,val>, <p,new>)$
		\State $Res_p \gets ret$
		\State \Return $ret$
		\EndProcedure
		
		\Procedure{recover}{}
		\State Read C, R[p][$*$]
		\If {$<p,new>$ appears in C, or $new$ appears in R[p][$*$]}
		\State $Res_p \gets true$
		\State \Return $true$
		\Else {}
		\State \Return $abort$
		\EndIf
		\EndProcedure
	\end{algorithmic}
	\caption{C.cas(old,new) by process $p$}
\end{algorithm}


Following the code, a process crash before line 7 will abort its operation upon recovering, while a crash at line 7 (and before completing the operation) will depend on whether the CAS was successful. A key point in this implementation is that a fail CAS operation can be aborted anyway, since it does not effect other processes and thus aborting it does not violate the sequential specification of the object. 



