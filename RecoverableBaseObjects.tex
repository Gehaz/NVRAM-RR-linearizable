
\section{Recoverable Base Objects}
\label{section: Recoverable Base Objects}

We consider a model in which the program counter is stored in the non-volatile memory. This can be done either explicitly in the program, or implicitly by the operating system. In this model, upon recovery the last PC is available, and the system knows during what operation the process crash, and thus the proper \texttt{Recover} function is invoked. As a result, there is uncertainty regarding whether the last instruction was performed or not.

The following example clarify why do we need the extension of recoverable object definition to holds even for the case of primitives.
Consider an object supporting compare-and-swap (CAS) atomic operation. Assume a process $p$ is executing an operation $res \leftarrow C.CAS(old,new)$ and crashes. There are several options for at what exact time the crash took place, and each case raises a different problem.

In the standard crash model, a primitive operation took effect instantly in the history, that is, the response followed the invocation in the history, where no other step by any other process was allowed in between. Under the same definition, and assuming the process crash just after completing the CAS operation, and before advancing the PC, there was a response step in the history, and thus the RR-linearizability does not require the process to recover the operation. However, the operation is still pending in some sense, as upon recovery the process does not know whether it took affect of no, since the PC still points the same line, and $res$ content was erased.

Considering the response of the CAS operation to be at the time where the PC is advance solves the above problem. Nevertheless, what if the process crashes just after the PC was changed? Again, the operation is not pending, so there is no need to recover it. In this case, upon recovery the process knows the operation completed, since the PC no longer points to it. Nevertheless, the process have no access to the response value that was stored in $res$, residing in the cache, and hence it may not be able to proceed its execution.

In order to face those problems we would like to have a definition under which, if a process crash after completing its operation, then upon recovery the process aware to fact the operation was completed, as well as have an access to the response value. For that, we define an object as \textit{recoverable} if in addition to a \texttt{Recover} function, the response step is determined to be at the point where the PC is updated to point outside of the operation implementation. Moreover, if the operation have a non-trivial response value (e.g., CAS or swap) the call for the operation gets another argument which is a pointer to a location in the non-volatile memory, such that the response value is written to this location before the operation completes.
Under this definition, if a process fails after the operation was completed, upon recovery it knows the operation was completed using the PC, as well as have an access to the response value residing in the main memory.

Notice that the requirement from the operation to store the response value in the non-volatile memory is not part of the object specification, but rather an "artificial" behaviour we require. The linearization points of the object only needs to 






A system equipped with recoverable primitives can be used to implement any object in a recoverable way in the following manner: in case of a crash the process will simply recover the last atomic operation along which the process crashed. Once the operation completes, the process can continue and execute the remaining code safely. This observation focus our attention to implementation of primitives in a recoverable manner.

In the following section we present RR-linearizable implementations for well known primitives, as well as presenting impossibility result for others. We focus our attention on bounded wait-free implementations, that is, the number of steps a process takes when executing the recovery code in the absence of a failure is finite and bounded by a known constant (may be a function of n, the number of processes in the system), regardless of the other processes steps and the failures the process experienced so far. In addition, we would like the recovery code to use a finite number of variables.
The fact that RR-linearizabilty allows us to swift the linearization point of an operation to after the crash is used to recover after a primitive failure.

\paragraph*{Read}

The process simply aborts the read upon recovering. Since read does not affect other processes, aborting the operation does not damage the linearizability of the program.

\paragraph*{Write}
Write instruction is "wrap" with code such that in case of a failure the extra data will be used for recovering. For an instruction writing value $x$ to variable $R$ by process $p$, we provide the following implementation. We use the convention of capital letters names for shared memory variables, and small letters for local ones. In the following code, $R_p$ is a variable in the memory designated for process $p$.

\begin{algorithm}
	\caption{Write}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{write operation}{}
		\State $res \gets R$
		\State $R_{p} \gets res$
		\State $R \gets x$
		\EndProcedure
		
		\Procedure{recovery code}{}
		\If {$R_{p} == R$} \Return abort
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

For simplicity, we write the recovery code as a single instruction, although it needs to be written as several instructions, as it accesses two different locations in the shared memory. Since $R_p$ is accessed by $p$ only, the point where $p$ reads $R$ determines the recovery code outcome. Moreover, in case of a failure along the recovery code, the process can simply restart it, as it contains only reads.

The intuition for correctness is that if there was a write to $R$ between the two reads of $p$ (at line 2, and at the recovery code), then either this write is by $p$, and we can linearize it at the point where it took affect, or that there was a write by some other process, and we can linearize the write of $p$ just before it. Hence, the real write "overwrite" $p$'s write, and the rest of the processes can not distinguish between the two situations. Therefore, in case of a failure before line 4, $p$ will simply abort upon recovering, and in case of a failure at line 4, $p$ will execute the recovery code.

The above analysis ignores the ABA problem. It might be that $p$ reads the same value from $R$, even though there was a write to $R$ in between the two different reads. To overcome this problem, we can augment any value written with the writing process's id, and a sequential number (each process will have its own sequential number). This way, reading the same value guarantee that no write to $R$ took place between the two different reads.


\paragraph*{Compare-and-Swap}

A Compare-and-Swap (CAS) object supports a single operation which atomically compares the value of the shared variable with its first parameter, and if they are equal, sets the value of the variable to its second parameter.
At a high level, a process $p$ first reads the CAS variable. If it observes a value different then $old$, then it return false. In such case, the operation can be linearized at the time of the read. Otherwise, $p$ announce the process which is value was stored in the CAS object, that it reads its value, by writing to a designated memory, and only then it can try and apply the CAS operation to the object. This way, if $p$ fails after a successful CAS operation, a different process that wants to change the value of the CAS, first needs to announce $p$ his CAS was successful. Therefore, upon recovery, $p$ can identify if its CAS took affect by reading $C$, and looking for an info by different process that have seen $p$'s value.
\begin{algorithm}
	\caption{Compare-and-Swap}\label{euclid}
	\begin{algorithmic}[1]
		\Procedure{cas operation}{}
		\State $<id,val> \gets C$
		\If {$val \neq old$}
		\State \Return false
		\EndIf
		\State $R[id][i] \gets val$
		\State $res \gets C.cas(<id,val>, <i,new>)$
		\EndProcedure
		
		\Procedure{recovery code}{}
		\State Read C, R[i][*]
		\If {$<id,val>$ appears in C, or $val$ appears in R[i][*]}
		\State \Return true
		\Else {}
		\State \Return false
		\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
